import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from IPython.display import Image
from scipy.interpolate import interp1d

# Setup
%matplotlib inline

# Robot and motion settings
wheel_radius = 0.05
robot_radius = 0.15
imu_drift_per_sec = np.deg2rad(1)
wheel_angles = np.deg2rad([0, 120, 240])

# input your way points

waypoints = np.array([
    [2.00, 2.00],
    [2.96, 2.21],
    [3.85, 2.43],
    [4.68, 2.66],
    [5.45, 2.90],
    [6.19, 3.15],
    [6.90, 3.42],
    [7.59, 3.69],
    [8.27, 3.98],
    [8.95, 4.28],
    [9.64, 4.60],
    [10.33, 4.92],
    [11.04, 5.26],
    [11.78, 5.61],
    [12.53, 5.98],
    [13.32, 6.35],
    [14.13, 6.74],
    [14.98, 7.14],
    [15.86, 7.55],
    [16.77, 7.97],
    [17.72, 8.40],
    [18.70, 8.84],
    [19.72, 9.28],
    [20.77, 9.74],
    [21.86, 10.17],
    [23.03, 10.47],
    [24.21, 10.93],
    [25.34, 11.54],
    [26.46, 12.15],
    [27.68, 12.65],
    [28.91, 13.15],
    [30.17, 13.66],
    [31.43, 14.18],
    [32.71, 14.70],
    [34.00, 15.23],
    [35.30, 15.76],
    [36.60, 16.29],
    [37.90, 16.83],
    [39.20, 17.38],
    [40.50, 17.93],
    [41.79, 18.49],
    [43.08, 19.05],
    [44.35, 19.62],
    [45.62, 20.20],
    [46.86, 20.78],
    [48.10, 21.38],
    [49.31, 21.98],
    [50.51, 22.60],
    [51.69, 23.23],
    [52.85, 23.88],
    [53.99, 24.54],
    [55.10, 25.22],
    [56.20, 25.92],
    [57.27, 26.64],
    [58.32, 27.38],
    [59.35, 28.15],
    [60.36, 28.95],
    [61.35, 29.77],
    [62.41, 30.29],
    [63.61, 30.67],
    [64.88, 31.27],
    [66.16, 32.12],
    [67.36, 33.23],
    [68.38, 34.55],
    [69.17, 36.00],
    [69.68, 37.48],
    [69.94, 38.88],
    [70.47, 40.16],
    [71.34, 41.46],
    [72.21, 42.81],
    [73.08, 44.22],
    [73.96, 45.69],
    [74.84, 47.21],
    [75.73, 48.78],
    [76.63, 50.42],
    [77.54, 52.11],
    [78.45, 53.86],
    [79.38, 55.66],
    [80.32, 57.51],
    [81.27, 59.41],
    [82.22, 61.35],
    [83.19, 63.34],
    [84.15, 65.36],
    [85.13, 67.42],
    [86.10, 69.49],
    [87.06, 71.59],
    [88.02, 73.68],
    [89.04, 75.73],
    [89.87, 77.86],
    [90.75, 79.91],
    [91.59, 81.92],
    [92.37, 83.87],
    [93.09, 85.75],
    [93.74, 87.54],
    [94.29, 89.21],
    [94.73, 90.74],
    [95.04, 92.12],
    [95.21, 93.30],
    [95.20, 94.28],
    [95.00, 95.00]
])




dt = 0.1
speed = 2  # Constant speed in m/s
robot_pos = waypoints[0].astype(float)
robot_vel = np.zeros(2)
robot_theta = 0
imu_drift = 0

# Precompute smooth path using interpolation
t_points = np.arange(len(waypoints))
interp_x = interp1d(t_points, waypoints[:, 0], kind='cubic')
interp_y = interp1d(t_points, waypoints[:, 1], kind='cubic')

# Estimate path length
def compute_path_length(x, y):
    distances = np.sqrt(np.diff(x)**2 + np.diff(y)**2)
    return np.sum(distances)

# Generate fine points along the path
t_fine = np.linspace(0, len(waypoints) - 1, 200)
x_fine = interp_x(t_fine)
y_fine = interp_y(t_fine)
total_length = compute_path_length(x_fine, y_fine)
total_time = total_length / speed
num_frames = int(total_time / dt) + 1

# Precompute positions for each frame
t_path = np.linspace(0, len(waypoints) - 1, num_frames)
path_x = interp_x(t_path)
path_y = interp_y(t_path)
path_history = []

# Plot setup
fig, ax = plt.subplots(figsize=(15, 15))
ax.set_aspect('equal')
ax.set_xlim(-1, 100)
ax.set_ylim(-1, 100)
ax.plot(waypoints[:, 0], waypoints[:, 1], 'ro', label='Waypoints')
ax.plot(x_fine, y_fine, 'k--', alpha=0.3, label='Smooth Path')
robot_dot, = ax.plot([], [], 'bo', label='Robot')
path_line, = ax.plot([], [], 'b-', linewidth=1, label='Robot Path')
velocity_text = ax.text(0,2, '', fontsize=40, horizontalalignment='left', verticalalignment='bottom')
plt.legend(loc='upper left')  # Moved legend to top-right corner

def update(frame):
    global robot_pos, robot_theta, imu_drift, robot_vel

    # Clear old arrows
    for p in reversed(ax.patches):
        p.remove()

    # Set position from precomputed path
    robot_pos[0] = path_x[frame]
    robot_pos[1] = path_y[frame]
    path_history.append(robot_pos.copy())

    # Calculate velocity based on position differences
    if frame > 0:
        dx = path_x[frame] - path_x[frame - 1]
        dy = path_y[frame] - path_y[frame - 1]
        robot_vel[:] = [dx / dt, dy / dt]
        # Normalize to constant speed
        velocity_mag = np.linalg.norm(robot_vel)
        if velocity_mag > 0:
            robot_vel *= speed / velocity_mag
    else:
        robot_vel[:] = [0, 0]  # No velocity at start

    # Update heading
    true_heading = np.arctan2(robot_vel[1], robot_vel[0])
    imu_drift += imu_drift_per_sec * dt
    robot_theta = true_heading

    # Update path line
    path_x_history = [pos[0] for pos in path_history]
    path_y_history = [pos[1] for pos in path_history]
    path_line.set_data(path_x_history, path_y_history)

    # Update robot dot
    robot_dot.set_data(robot_pos[0], robot_pos[1])

    # Velocity arrow
    velocity_mag = np.linalg.norm(robot_vel)
    v_dir = robot_vel / velocity_mag if velocity_mag > 0 else np.zeros(2)
    ax.arrow(robot_pos[0], robot_pos[1], v_dir[0]*0.4, v_dir[1]*0.4, color='green', width=0.01)

    # Heading arrow
    ax.arrow(robot_pos[0], robot_pos[1], 0.3*np.cos(robot_theta), 0.3*np.sin(robot_theta), color='blue', width=1)

    # Wheel velocity arrows and text
    v_x, v_y = robot_vel
    wheel_vels = []
    for alpha in wheel_angles:
        w = (np.cos(alpha) * v_x + np.sin(alpha) * v_y) / wheel_radius
        linear_vel = w * wheel_radius
        wheel_vels.append(linear_vel)
        dx = 0.15 * np.cos(alpha) * linear_vel
        dy = 0.15 * np.sin(alpha) * linear_vel
        ax.arrow(robot_pos[0], robot_pos[1], dx, dy, color='red', width=0.002)

    # Update text with wheel velocities
    text_str = '\n'.join([f'Wheel {i+1}: {vel:.2f}' for i, vel in enumerate(wheel_vels)])
    velocity_text.set_text(text_str)

    return [robot_dot, path_line, velocity_text]

# Animation
anim = FuncAnimation(fig, update, frames=num_frames, interval=100, blit=False)
anim.save("omni_sim_smooth_curves.gif", writer=PillowWriter(fps=10))

# Display in Jupyter (optional)
Image("omni_sim_smooth_curves.gif")
